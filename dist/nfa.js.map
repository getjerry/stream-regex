{"version":3,"file":"nfa.js","names":["_stream","require","_debug","_interopRequireDefault","_each","_isNil","_range","_some","_every","_isArray","_reduce","_map","_ast","obj","__esModule","default","debugLogger","debug","createRangePostfixNodes","node","start","end","pfNodes","notEqual","newNodes","each","range","charCodeAt","charCode","push","from","type","value","String","fromCharCode","length","createPostfixNodesWithQuantifier","operands","quantifier","minStr","maxStr","isArray","Error","min","parseInt","max","pushCount","res","createPostfix","regex","hasEndMatcher","hasStartMatcher","_createPostfix","subExp","idx","expressionItems","expressionItem","getValue","pfNode","reduce","memo","n","count","val","replace","map","isNil","exclusionGroup","undefined","postfix","getAST","exports","patch","ptrList","state","ptr","outAttr","postfixToNFA","stack","p","e2","pop","e1","out","s","out1","e","char","match","input","options","listID","opts","greedy","global","ignoreCase","processingStreamHighWaterMark","addState","list","lastListID","step","nextStates","srcChar","toLowerCase","stateCharArray","hasMatch","every","stateChar","stateCharLower","_doMatchStream","highWaterMark","strBuffer","lastMatch","matchStream","PassThrough","readableObjectMode","writableHighWaterMark","_write","chunk","encoding","callback","chunkStr","toString","i","some","matchedValue","srcValue","substring","_final","doMatchStream","replaceStream","Readable","_read","matchSucceeded","lastMatchedString","rejectMatching","pipe","on","str","onReplace","matchToEnd","matchFromStart"],"sources":["../src/nfa.ts"],"sourcesContent":["import { Readable, PassThrough } from 'stream';\n\nimport debug from 'debug';\nimport each from 'lodash/each';\nimport isNil from 'lodash/isNil';\nimport range from 'lodash/range';\nimport some from 'lodash/some';\nimport every from 'lodash/every';\nimport isArray from 'lodash/isArray';\nimport reduce from 'lodash/reduce';\nimport map from 'lodash/map';\n\nimport type { AST } from './ast';\nimport { getAST, getValue } from './ast';\n\nconst debugLogger = debug('NFA');\n\nexport interface PostfixNode {\n  from: string;\n  type: string;\n  value: string | string[];\n  notEqual?: boolean;\n}\n\n/**\n * Helper function to construct the postfix notation for a range of characters.\n * TODO: This is inefficient. We should construct the NFA from the range directly instead of creating a node for each character.\n *\n * @param node\n * @param start\n * @param end\n * @param pfNodes\n * @param notEqual\n */\nconst createRangePostfixNodes = (node: AST, start: string, end: string, pfNodes: PostfixNode[], notEqual?: boolean): PostfixNode[] => {\n  const newNodes = [...pfNodes];\n  each(range(start.charCodeAt(0), end.charCodeAt(0) + 1), (charCode) => {\n    newNodes.push({ from: node.type, type: 'operand', value: String.fromCharCode(charCode), notEqual });\n    if (newNodes.length > 1) {\n      newNodes.push({ from: node.type, type: 'operator', value: '|' });\n    }\n  });\n  return newNodes;\n}\n\nconst createPostfixNodesWithQuantifier = (operands: PostfixNode[], quantifier: PostfixNode[]): PostfixNode[] => {\n  // Single character quantifier (`?` or `*` or `+`)\n  if (quantifier.length <= 1) {\n    return [\n      ...operands,\n      ...quantifier,\n    ];\n  }\n  // Range quantifier (`{m,n}`)\n  const minStr = quantifier[0].value;\n  const maxStr = quantifier[1].value;\n  if (isArray(minStr) || isArray(maxStr)) {\n    throw new Error(`Invalid quantifier: ${minStr} - ${maxStr}`);\n  }\n\n  const min = minStr ? parseInt(minStr, 10) : 0;\n  const max = maxStr ? parseInt(maxStr, 10) : -1;\n  if (max !== -1 && max < min) {\n    throw new Error(`Invalid quantifier: ${min} - ${max}`);\n  }\n\n  // To handle the `min`, we concatenate the operands `min` times.\n  let pushCount = 0;\n  const res: PostfixNode[] = [];\n  each(range(0, min), () => {\n    res.push(...operands);\n    pushCount++;\n    if (pushCount > 1) {\n      res.push({ from: 'quantifier', type: 'operator', value: '.' });\n    }\n  });\n\n  // If max is not specified (i.e. -1), then we match 0 or more times.\n  if (max === -1) {\n    res.push(...operands);\n    res.push({ from: 'quantifier', type: 'operator', value: '*' });\n    pushCount++;\n    if (pushCount > 1) {\n      res.push({ from: 'quantifier', type: 'operator', value: '.' });\n    }\n  } else {\n    // To handle the `max`, we add the operands \"optionally\" `max - min` times.\n    each(range(min, max), () => {\n      res.push(...operands);\n      res.push({ from: 'quantifier', type: 'operator', value: '?' });\n      pushCount++;\n      if (pushCount > 1) {\n        res.push({ from: 'quantifier', type: 'operator', value: '.' });\n      }\n    });\n  }\n\n  return res;\n}\n\n/**\n * Converts an AST to postfix notation.\n *\n * @param regex\n */\nexport const createPostfix = (regex: RegExp) => {\n  let hasEndMatcher = false;\n  let hasStartMatcher = false;\n\n  /**\n   * Recursively creates the postfix notation.\n   *\n   * @param node\n   * @param notEqual - If true, the node character value is matched against any character except the one specified.\n   */\n  const _createPostfix = (node: AST, notEqual: boolean | undefined): PostfixNode[] => {\n    switch (node.type) {\n      case 'expression':\n        {\n          hasStartMatcher = node.value[0].value.length !== 0;\n          const pfNodes: PostfixNode[] = [];\n          each([node.value[1], ...node.value[3].value], (subExp, idx) => {\n            pfNodes.push(..._createPostfix(subExp, notEqual));\n            if (idx > 0 && idx <= node.value[3].value.length) {\n              pfNodes.push({ from: node.type, type: 'operator', value: '|' });\n            }\n          });\n          return pfNodes;\n        }\n      case 'subExpression':\n        {\n          // This node is an iteration list. Unroll.\n          const expressionItems = node.value[0].value;\n          const pfNodes: PostfixNode[] = [];\n          each(expressionItems, (expressionItem, idx) => {\n            hasEndMatcher = getValue(expressionItem) === '$';\n            if (hasEndMatcher) {\n              return false;\n            }\n            pfNodes.push(..._createPostfix(expressionItem, notEqual));\n            if (idx > 0 && idx < expressionItems.length) {\n              pfNodes.push({ from: node.type, type: 'operator', value: '.' });\n            }\n          });\n          return pfNodes;\n        }\n      case 'characterGroupInner':\n        {\n          // This node is an iteration list. Unroll.\n          const expressionItems = node.value[0].value;\n          const pfNodes: PostfixNode[] = [];\n          each(expressionItems, (expressionItem, idx) => {\n            // Character groups with the '^' exclusion character need to have have all characters in a single node.\n            if (!notEqual) {\n              pfNodes.push(..._createPostfix(expressionItem, notEqual));\n            } else {\n              const pfNode: PostfixNode = reduce(_createPostfix(expressionItem, notEqual), (memo, n) => ({\n                ...memo,\n                value: [...memo.value, ...n.value],\n              }), {\n                from: node.type,\n                type: 'operand',\n                value: [] as string[],\n                notEqual,\n              });\n              if (idx === 0) {\n                pfNodes.push(pfNode);\n              } else {\n                pfNodes[0].value = [...pfNodes[0].value, ...pfNode.value];\n              }\n            }\n\n            // Character groups without the '^' exclusion character need to have an OR operator between each character.\n            if (!notEqual && idx > 0 && idx < expressionItems.length) {\n              pfNodes.push({ from: node.type, type: 'operator', value: '|' });\n            }\n          });\n          return pfNodes;\n        }\n      case 'expressionItem':\n      case 'matchCharacterClass':\n      case 'characterGroupItem':\n      case 'characterRange':\n      case 'matchItem':\n      case 'group':\n        {\n          // Should have only one child.\n          return _createPostfix(node.value[0], notEqual);\n        }\n      case 'groupExpression':\n        {\n          const quantifier = node.value[4].value.length ? _createPostfix(node.value[4].value[0], notEqual) : [];\n          const operands = _createPostfix(node.value[2], notEqual);\n          return createPostfixNodesWithQuantifier(operands, quantifier); \n          // return [\n          //   ..._createPostfix(node.value[2], notEqual),\n          //   ...(quantifier ? [{ from: node.type, type: 'operator', value: quantifier }] : []),\n          // ];\n        }\n      case 'match':\n        {\n          const quantifier = node.value[1].value.length ? _createPostfix(node.value[1].value[0], notEqual) : [];\n          const operands = _createPostfix(node.value[0], notEqual);\n          return createPostfixNodesWithQuantifier(operands, quantifier);\n          // return [\n          //   ..._createPostfix(node.value[0], notEqual),\n          //   ...(quantifier ? [{ from: node.type, type: 'operator', value: quantifier }] : []),\n          // ];\n        }\n      case 'quantifier':\n        return _createPostfix(node.value[0], notEqual);\n      case 'quantifierType':\n        if (node.value.length === 0) {\n          return [];\n        }\n        if (node.value[0].value.length === 1) {\n          return [{ from: node.type, type: 'operator', value: getValue(node) }];\n        }\n        return _createPostfix(node.value[0], notEqual);\n      case 'matchCount1':\n        {\n          const count = getValue(node.value[1]);\n          return [{ from: node.type, type: 'operator', value: count }, { from: node.type, type: 'operator', value: count }];\n        }\n      case 'matchCount2':\n        return [{ from: node.type, type: 'operator', value: getValue(node.value[1]) }, { from: node.type, type: 'operator', value: getValue(node.value[3]) }];\n      case 'character':\n      case 'characterClass':\n        {\n          let val = getValue(node);\n          if (node.type !== 'characterClass') {\n            val = val.replace(/^\\\\/, '');\n            return [{ from: node.type, type: 'operand', value: val, notEqual }];\n          }\n          switch (val) {\n           case '\\\\w':\n            {\n              let pfNodes: PostfixNode[] = [];\n              pfNodes = createRangePostfixNodes(node, 'a', 'z', pfNodes, notEqual);\n              pfNodes = createRangePostfixNodes(node, 'A', 'Z', pfNodes, notEqual);\n              pfNodes = createRangePostfixNodes(node, '0', '9', pfNodes, notEqual);\n              pfNodes.push({ from: node.type, type: 'operand', value: '_', notEqual: notEqual });\n              pfNodes.push({ from: node.type, type: 'operator', value: '|' });\n              return pfNodes;\n            }\n            case '\\\\W':\n              return [{\n                from: node.type,\n                type: 'operand',\n                value: map([\n                  ...range('a'.charCodeAt(0), 'z'.charCodeAt(0) + 1),\n                  ...range('A'.charCodeAt(0), 'Z'.charCodeAt(0) + 1),\n                  ...range('0'.charCodeAt(0), '9'.charCodeAt(0) + 1),\n                  '_'.charCodeAt(0),\n                ], (charCode) => String.fromCharCode(charCode)),\n                notEqual: true,\n              }];\n            case '\\\\d':\n              return createRangePostfixNodes(node, '0', '9', [], notEqual);\n            case '\\\\D':\n              return [{\n                from: node.type,\n                type: 'operand',\n                value: map(range('0'.charCodeAt(0), '9'.charCodeAt(0) + 1), (charCode) => String.fromCharCode(charCode)),\n                notEqual: true,\n              }];\n            case '\\\\s':\n              {\n                const pfNodes: PostfixNode[] = [];\n                pfNodes.push({ from: node.type, type: 'operand', value: ' ', notEqual: notEqual });\n                pfNodes.push({ from: node.type, type: 'operand', value: '\\t', notEqual: notEqual });\n                pfNodes.push({ from: node.type, type: 'operator', value: '|' });\n                pfNodes.push({ from: node.type, type: 'operand', value: '\\n', notEqual: notEqual });\n                pfNodes.push({ from: node.type, type: 'operator', value: '|' });\n                pfNodes.push({ from: node.type, type: 'operand', value: '\\r', notEqual: notEqual });\n                pfNodes.push({ from: node.type, type: 'operator', value: '|' });\n                pfNodes.push({ from: node.type, type: 'operand', value: '\\f', notEqual: notEqual });\n                pfNodes.push({ from: node.type, type: 'operator', value: '|' });\n                pfNodes.push({ from: node.type, type: 'operand', value: '\\v', notEqual: notEqual });\n                pfNodes.push({ from: node.type, type: 'operator', value: '|' });\n                return pfNodes;\n              }\n            case '\\\\S':\n              return [{\n                from: node.type,\n                type: 'operand',\n                value: [' ', '\\t', '\\n', '\\r', '\\f', '\\v'],\n                notEqual: true,\n              }];\n            default:\n              throw new Error(`Do not know how to handle: \"${val}\"`);\n          }\n        }\n      case 'anyChar':\n        {\n          return [{ from: node.type, type: 'operand', value: '', notEqual: isNil(notEqual) ? true : !notEqual}];\n        }\n      case 'characterGroup':\n        {\n          // Check if the '^' slot is not empty. This means that the group is an exclusion group.\n          const exclusionGroup = node.value[1].value[0];\n          return _createPostfix(node.value[2], exclusionGroup ? true : undefined);\n        }\n      case 'characterRangeItem':\n        {\n          const start = getValue(node.value[0]);\n          const end = getValue(node.value[2]);\n          const pfNodes: PostfixNode[] = [];\n          return createRangePostfixNodes(node, start, end, pfNodes, notEqual);\n        }\n      default:\n        throw new Error(`Do not know how to handle: \"${node.type}\"`);\n    }\n  };\n\n  return {\n    postfix: _createPostfix(getAST(regex), undefined),\n    hasStartMatcher,\n    hasEndMatcher,\n  };\n}\n\nexport interface State {\n  type: 'Split' | 'Match' | 'Char';\n  notEqual?: boolean;\n  // For `Char` type, this is the character to match.\n  char?: string | string[];\n  // The next state to go to.\n  out: State | null;\n  // For `Split` type, this is the second state to go to.\n  out1: State | null;\n  // This field is used in the NFA stepping algorithm to prevent adding the same state to a list multiple times.\n  lastListID?: number;\n}\n\ninterface FragOutPtr {\n  state: State;\n  outAttr: 'out' | 'out1';\n}\n\ninterface Frag {\n  start: State;\n  out: FragOutPtr[];\n}\n\n/**\n * Patches the NFA fragment with the new state.\n * The dangling pointers are set to the provided state.\n *\n * @param ptrList\n * @param state\n */\nconst patch = (ptrList: FragOutPtr[], state: State) => {\n  each(ptrList, (ptr) => {\n    if (ptr.state[ptr.outAttr] === null) {\n      ptr.state[ptr.outAttr] = state;\n    }\n  });\n}\n\n/**\n * Converts the postfix notation to an NFA.\n *\n * @param postfix\n */\nexport const postfixToNFA = (postfix: PostfixNode[]): State | undefined => {\n  const stack: Frag[] = [];\n\n  each(postfix, (p) => {\n    if (p.type === 'operator') {\n      switch (p.value) {\n        // Concatenation\n        case '.':\n          {\n            const e2 = stack.pop();\n            const e1 = stack.pop();\n            if (!e1 || !e2) {\n              throw new Error('Invalid postfix expression');\n            }\n            patch(e1.out, e2.start);\n            stack.push({ start: e1.start, out: e2.out });\n          }\n          break;\n        // Alternation\n        case '|':\n          {\n            const e2 = stack.pop();\n            const e1 = stack.pop();\n            if (!e1 || !e2) {\n              throw new Error('Invalid postfix expression');\n            }\n            const s: State = { type: 'Split', out: e1.start, out1: e2.start };\n            stack.push({ start: s, out: [...e1.out, ...e2.out] });\n          }\n          break;\n        // Zero or one\n        case '?':\n          {\n            const e = stack.pop();\n            if (!e) {\n              throw new Error('Invalid postfix expression');\n            }\n            const s: State = { type: 'Split', out: e.start, out1: null };\n            stack.push({ start: s, out: [{ state: s, outAttr: 'out1' }, ...e.out] });\n          }\n          break;\n        // Zero or more\n        case '*':\n          {\n            const e = stack.pop();\n            if (!e) {\n              throw new Error('Invalid postfix expression');\n            }\n            const s: State = { type: 'Split', out: e.start, out1: null };\n            patch(e.out, s);\n            stack.push({ start: s, out: [{ state: s, outAttr: 'out1' }] });\n          }\n          break;\n        // One or more\n        case '+':\n          {\n            const e = stack.pop();\n            if (!e) {\n              throw new Error('Invalid postfix expression');\n            }\n            const s: State = { type: 'Split', out: e.start, out1: null };\n            patch(e.out, s);\n            stack.push({ start: e.start, out: [{ state: s, outAttr: 'out1' }] });\n          }\n          break;\n        default:\n          throw new Error(`Unknown operator: ${p.value}`);\n      }\n    } else {\n      const s: State = { type: 'Char', char: p.value, notEqual: p.notEqual, out: null, out1: null };\n      stack.push({ start: s, out: [{ state: s, outAttr: 'out' }] });\n    }\n  });\n\n  // The stack should have only one fragment left.\n  // Patch in the match state.\n  const e = stack.pop();\n  if (!e) {\n    throw new Error('Invalid postfix expression');\n  }\n  patch(e.out, { type: 'Match', out: null, out1: null });\n  \n  return e.start;\n};\n\ninterface MatchOptions {\n  // If true, the algorithm will try to match the longest possible string. If false, it will try to match the shortest possible string.\n  // default: true\n  greedy?: boolean;\n  // If true, the algorithm will try to match all occurrences of the pattern in the input string. If false, it will only try to match the first occurrence.\n  // default: false\n  global?: boolean;\n  // If true, the algorithm will ignore the case of the input string.\n  // default: false\n  ignoreCase?: boolean;\n  // If true, the algorithm will match from the start of the input string.\n  // default: false\n  matchFromStart?: boolean;\n  // If true, the algorithm will match to the end of the input string.\n  // default: false\n  matchToEnd?: boolean;\n  // If provided, the algorithm will replace the matched string with the return value of this function.\n  onReplace?: (val: string) => string;\n  // Size of the highWaterMark for the processing stream.\n  // default: 1024\n  processingStreamHighWaterMark?: number;\n}\n\ninterface _MatchResult {\n  matchedValue: string | undefined;\n  srcValue: string;\n}\n\n/**\n * Runs the NFA on the input string.\n *\n * @param start - The start state of the NFA.\n * @param input - Input stream to match.\n * @param options - Options for the match.\n */\nexport const match = (start: State, input: Readable, options?: MatchOptions) => {\n  // This ID is used to prevent adding the same state to a list multiple times.\n  // We do this by giving each state list a unique ID (listID) and then setting the lastList property of the state to the listID.\n  // If the lastList property of the state is the same as the listID, we skip adding the state to the list.\n  let listID = 1;\n  // Default options.\n  const opts: MatchOptions = {\n    greedy: true,\n    global: false,\n    ignoreCase: false,\n    processingStreamHighWaterMark: 1024,\n    ...options,\n  };\n\n  /**\n   * Adds a state to the list. Handles the split nodes by adding both out and out1 states.\n   *\n   * @param list\n   * @param s\n   */\n  const addState = (list: State[], s: State | null) => {\n    // If the state is null or the lastList property is the same as the listID, skip adding the state to the list.\n    if (s === null || s.lastListID === listID) {\n      return;\n    }\n\n    s.lastListID = listID;\n    // If the state is a split node, add both out and out1 states.\n    if (s.type === 'Split') {\n      addState(list, s.out);\n      addState(list, s.out1);\n      return;\n    }\n    list.push(s);\n  }\n  \n  /**\n   * Runs one step of NFA on the input character.\n   * The output is the next state list.\n   *\n   * @param list\n   * @param char\n   */\n  const step = (list: State[], char: string) => {\n    debugLogger('[step] Step: %o', { listID, char });\n\n    listID++;\n    const nextStates: State[] = [];\n    each(list, (state) => {\n      if (state.type === 'Char' && !isNil(state.char)) {\n        const srcChar = opts.ignoreCase ? char.toLowerCase() : char;\n        const stateCharArray = isArray(state.char) ? state.char : [state.char];\n        const hasMatch = every(stateCharArray, (stateChar) => {\n          const stateCharLower = opts.ignoreCase ? stateChar.toLowerCase() : stateChar;\n          return (state.notEqual ? stateCharLower !== srcChar : stateCharLower === srcChar);\n        });\n        if (hasMatch) {\n          debugLogger('[step] Match: %o', state);\n          addState(nextStates, state.out);\n        } else {\n          debugLogger('[step] No match: %o', state);\n        }\n      }\n    });\n\n    debugLogger('[step] Next states: %o', nextStates);\n    return nextStates;\n  }\n\n  /**\n   * Main function. Runs the NFA on the input stream.\n   *\n   * @param start\n   * @param greedy\n   * @param highWaterMark\n   */\n  const _doMatchStream = (start: State, greedy: boolean, highWaterMark?: number) => {\n    let list: State[] = [];\n\n    let strBuffer = '';\n    let lastMatch: string | undefined = undefined;\n\n    const matchStream = new PassThrough({ readableObjectMode: true, writableHighWaterMark: highWaterMark });\n    matchStream._write = (chunk, encoding, callback) => {\n      const chunkStr = chunk.toString();\n      for (let i = 0; i < chunkStr.length; i++) {\n        const char = chunkStr[i];\n        strBuffer += char;\n\n        if (list.length === 0) {\n          // Start the state list by adding the start state.\n          addState(list, start);\n        }\n\n        // Run one step of the NFA.\n        list = step(list, char);\n\n        // If we have a match, save the match and stop if not greedy.\n        if (some(list, (state) => state.type === 'Match')) {\n          debugLogger('[_doMatchStream] Has match');\n          lastMatch = strBuffer;\n\n          if (!greedy) {\n            matchStream.push({ matchedValue: lastMatch, srcValue: strBuffer });\n            strBuffer = '';\n            list = [];\n            lastMatch = undefined;\n          }\n        }\n\n        // If we have no more states to go to, then there is a mismatch. Exit early.\n        if (list.length === 0) {\n          debugLogger('[_doMatchStream] No match - early exit');\n          matchStream.push({ matchedValue: lastMatch, srcValue: lastMatch ? strBuffer.substring(0, strBuffer.length - 1) : strBuffer });\n          strBuffer = '';\n          list = [];\n          if (lastMatch) {\n            lastMatch = undefined;\n            i--;\n          }\n        }\n      }\n\n      callback();\n    };\n\n    // Flush any pending match.\n    matchStream._final = (callback) => {\n      matchStream.push({ matchedValue: lastMatch, srcValue: strBuffer });\n      callback();\n    }\n\n    return matchStream;\n  };\n\n  /**\n   * Entry point for running the NFA on the input stream. This function progressively matches the input stream.\n   *\n   * @param start\n   * @param input\n   * @param options\n   */\n  const doMatchStream = (start: State, input: Readable, options: MatchOptions) => {\n    // Output stream.\n    const replaceStream = new Readable();\n    // TODO: Respect the highWaterMark.\n    replaceStream._read = () => {};\n\n    // First match success flag.\n    let matchSucceeded = false;\n    // Most recent matched string.\n    let lastMatchedString: string | undefined = undefined;\n    // Reject matching flag.\n    let rejectMatching = false;\n\n    const matchStream = _doMatchStream(start, options.greedy || false, options.processingStreamHighWaterMark);\n    input\n      .pipe(matchStream)\n      .on('data', ({ matchedValue, srcValue }: _MatchResult) => {\n        let str = srcValue;\n\n        if (matchedValue) {\n          // If we're not matching globally, then we're done after the first match.\n          if (!rejectMatching && (options.global || !matchSucceeded)) {\n            if (options.onReplace) {\n              str = options.onReplace(matchedValue);\n            }\n          }\n          // Prevent further matching if we're matching globally.\n          matchSucceeded = true;\n\n          // If we're not matching to the end of stream, push the matched string to the output stream.\n          if (!options.matchToEnd) {\n            replaceStream.push(str)\n          } else if (!rejectMatching) {\n            // Record this match (used for end matching).\n            // The replacement processing is done at the end when the stream is finished. If subsequent chunks are not matched, then we'll need the original source string.\n            // NOTE: `global` has no effect on `matchToEnd`.\n            lastMatchedString = matchedValue;\n          }\n        } else {\n          // Start rejecting future matches after the first non-match if we're matching from the start.\n          rejectMatching = !!options.matchFromStart;\n          // On a non-match, the last matched string is treated as an unmatched string.\n          if (lastMatchedString) {\n            replaceStream.push(lastMatchedString);\n          }\n          replaceStream.push(str);\n          lastMatchedString = undefined;\n        }\n      })\n      .on('finish', () => {\n        // If we're matching to the end of stream, if a match has survived, run the replacement process and push to output.\n        if (options.matchToEnd) {\n          if (lastMatchedString) {\n            replaceStream.push(options.onReplace ? options.onReplace(lastMatchedString) : lastMatchedString);\n          }\n        }\n        replaceStream.push(null);\n      });\n\n    return replaceStream;\n  }\n\n  // Start the NFA.\n  return doMatchStream(start, input, opts);\n};"],"mappings":"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"}