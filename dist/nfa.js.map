{"version":3,"file":"nfa.js","names":["_stream","require","_debug","_interopRequireDefault","_each","_isNil","_range","_some","_every","_isArray","_reduce","_map","_ast","obj","__esModule","default","debugLogger","debug","createRangePostfixNodes","node","start","end","pfNodes","notEqual","newNodes","each","range","charCodeAt","charCode","push","from","type","value","String","fromCharCode","length","createPostfix","regex","hasEndMatcher","hasStartMatcher","_createPostfix","subExp","idx","expressionItems","expressionItem","getValue","pfNode","reduce","memo","n","quantifier","val","replace","map","Error","isNil","exclusionGroup","undefined","postfix","getAST","exports","patch","ptrList","state","ptr","outAttr","postfixToNFA","stack","p","e2","pop","e1","out","s","out1","e","char","match","input","options","listID","opts","greedy","global","ignoreCase","processingStreamHighWaterMark","addState","list","lastListID","step","nextStates","srcChar","toLowerCase","stateCharArray","isArray","hasMatch","every","stateChar","stateCharLower","_doMatchStream","highWaterMark","strBuffer","lastMatch","matchStream","PassThrough","readableObjectMode","writableHighWaterMark","_write","chunk","encoding","callback","chunkStr","toString","i","some","matchedValue","srcValue","substring","_final","doMatchStream","replaceStream","Readable","_read","matchSucceeded","lastMatchedString","rejectMatching","pipe","on","str","onReplace","matchToEnd","matchFromStart"],"sources":["../src/nfa.ts"],"sourcesContent":["import { Readable, PassThrough } from 'stream';\n\nimport debug from 'debug';\nimport each from 'lodash/each';\nimport isNil from 'lodash/isNil';\nimport range from 'lodash/range';\nimport some from 'lodash/some';\nimport every from 'lodash/every';\nimport isArray from 'lodash/isArray';\nimport reduce from 'lodash/reduce';\nimport map from 'lodash/map';\n\nimport type { AST } from './ast';\nimport { getAST, getValue } from './ast';\n\nconst debugLogger = debug('NFA');\n\nexport interface PostfixNode {\n  from: string;\n  type: string;\n  value: string | string[];\n  notEqual?: boolean;\n}\n\n/**\n * Helper function to construct the postfix notation for a range of characters.\n * TODO: This is inefficient. We should construct the NFA from the range directly instead of creating a node for each character.\n *\n * @param node\n * @param start\n * @param end\n * @param pfNodes\n * @param notEqual\n */\nconst createRangePostfixNodes = (node: AST, start: string, end: string, pfNodes: PostfixNode[], notEqual?: boolean): PostfixNode[] => {\n  const newNodes = [...pfNodes];\n  each(range(start.charCodeAt(0), end.charCodeAt(0) + 1), (charCode) => {\n    newNodes.push({ from: node.type, type: 'operand', value: String.fromCharCode(charCode), notEqual });\n    if (newNodes.length > 1) {\n      newNodes.push({ from: node.type, type: 'operator', value: '|' });\n    }\n  });\n  return newNodes;\n}\n\n/**\n * Converts an AST to postfix notation.\n *\n * @param regex\n */\nexport const createPostfix = (regex: RegExp) => {\n  let hasEndMatcher = false;\n  let hasStartMatcher = false;\n\n  /**\n   * Recursively creates the postfix notation.\n   *\n   * @param node\n   * @param notEqual - If true, the node character value is matched against any character except the one specified.\n   */\n  const _createPostfix = (node: AST, notEqual: boolean | undefined): PostfixNode[] => {\n    switch (node.type) {\n      case 'expression':\n        {\n          hasStartMatcher = node.value[0].value.length !== 0;\n          const pfNodes: PostfixNode[] = [];\n          each([node.value[1], ...node.value[3].value], (subExp, idx) => {\n            pfNodes.push(..._createPostfix(subExp, notEqual));\n            if (idx > 0 && idx <= node.value[3].value.length) {\n              pfNodes.push({ from: node.type, type: 'operator', value: '|' });\n            }\n          });\n          return pfNodes;\n        }\n      case 'subExpression':\n        {\n          // This node is an iteration list. Unroll.\n          const expressionItems = node.value[0].value;\n          const pfNodes: PostfixNode[] = [];\n          each(expressionItems, (expressionItem, idx) => {\n            hasEndMatcher = getValue(expressionItem) === '$';\n            if (hasEndMatcher) {\n              return false;\n            }\n            pfNodes.push(..._createPostfix(expressionItem, notEqual));\n            if (idx > 0 && idx < expressionItems.length) {\n              pfNodes.push({ from: node.type, type: 'operator', value: '.' });\n            }\n          });\n          return pfNodes;\n        }\n      case 'characterGroupInner':\n        {\n          // This node is an iteration list. Unroll.\n          const expressionItems = node.value[0].value;\n          const pfNodes: PostfixNode[] = [];\n          each(expressionItems, (expressionItem, idx) => {\n            // Character groups with the '^' exclusion character need to have have all characters in a single node.\n            if (!notEqual) {\n              pfNodes.push(..._createPostfix(expressionItem, notEqual));\n            } else {\n              const pfNode: PostfixNode = reduce(_createPostfix(expressionItem, notEqual), (memo, n) => ({\n                ...memo,\n                value: [...memo.value, ...n.value],\n              }), {\n                from: node.type,\n                type: 'operand',\n                value: [] as string[],\n                notEqual,\n              });\n              if (idx === 0) {\n                pfNodes.push(pfNode);\n              } else {\n                pfNodes[0].value = [...pfNodes[0].value, ...pfNode.value];\n              }\n            }\n\n            // Character groups without the '^' exclusion character need to have an OR operator between each character.\n            if (!notEqual && idx > 0 && idx < expressionItems.length) {\n              pfNodes.push({ from: node.type, type: 'operator', value: '|' });\n            }\n          });\n          return pfNodes;\n        }\n      case 'expressionItem':\n      case 'matchCharacterClass':\n      case 'characterGroupItem':\n      case 'characterRange':\n      case 'matchItem':\n      case 'group':\n        {\n          // Should have only one child.\n          return _createPostfix(node.value[0], notEqual);\n        }\n      case 'groupExpression':\n        {\n          const quantifier = getValue(node.value[4]);\n          return [\n            ..._createPostfix(node.value[2], notEqual),\n            ...(quantifier ? [{ from: node.type, type: 'operator', value: quantifier }] : []),\n          ];\n        }\n      case 'match':\n        {\n          const quantifier = getValue(node.value[1]);\n          return [\n            ..._createPostfix(node.value[0], notEqual),\n            ...(quantifier ? [{ from: node.type, type: 'operator', value: quantifier }] : []),\n          ];\n        }\n      case 'character':\n      case 'characterClass':\n        {\n          let val = getValue(node);\n          if (node.type !== 'characterClass') {\n            val = val.replace(/^\\\\/, '');\n            return [{ from: node.type, type: 'operand', value: val, notEqual }];\n          }\n          switch (val) {\n           case '\\\\w':\n            {\n              let pfNodes: PostfixNode[] = [];\n              pfNodes = createRangePostfixNodes(node, 'a', 'z', pfNodes, notEqual);\n              pfNodes = createRangePostfixNodes(node, 'A', 'Z', pfNodes, notEqual);\n              pfNodes = createRangePostfixNodes(node, '0', '9', pfNodes, notEqual);\n              pfNodes.push({ from: node.type, type: 'operand', value: '_', notEqual: notEqual });\n              pfNodes.push({ from: node.type, type: 'operator', value: '|' });\n              return pfNodes;\n            }\n            case '\\\\W':\n              return [{\n                from: node.type,\n                type: 'operand',\n                value: map([\n                  ...range('a'.charCodeAt(0), 'z'.charCodeAt(0) + 1),\n                  ...range('A'.charCodeAt(0), 'Z'.charCodeAt(0) + 1),\n                  ...range('0'.charCodeAt(0), '9'.charCodeAt(0) + 1),\n                  '_'.charCodeAt(0),\n                ], (charCode) => String.fromCharCode(charCode)),\n                notEqual: true,\n              }];\n            case '\\\\d':\n              return createRangePostfixNodes(node, '0', '9', [], notEqual);\n            case '\\\\D':\n              return [{\n                from: node.type,\n                type: 'operand',\n                value: map(range('0'.charCodeAt(0), '9'.charCodeAt(0) + 1), (charCode) => String.fromCharCode(charCode)),\n                notEqual: true,\n              }];\n            case '\\\\s':\n              {\n                const pfNodes: PostfixNode[] = [];\n                pfNodes.push({ from: node.type, type: 'operand', value: ' ', notEqual: notEqual });\n                pfNodes.push({ from: node.type, type: 'operand', value: '\\t', notEqual: notEqual });\n                pfNodes.push({ from: node.type, type: 'operator', value: '|' });\n                pfNodes.push({ from: node.type, type: 'operand', value: '\\n', notEqual: notEqual });\n                pfNodes.push({ from: node.type, type: 'operator', value: '|' });\n                pfNodes.push({ from: node.type, type: 'operand', value: '\\r', notEqual: notEqual });\n                pfNodes.push({ from: node.type, type: 'operator', value: '|' });\n                pfNodes.push({ from: node.type, type: 'operand', value: '\\f', notEqual: notEqual });\n                pfNodes.push({ from: node.type, type: 'operator', value: '|' });\n                pfNodes.push({ from: node.type, type: 'operand', value: '\\v', notEqual: notEqual });\n                pfNodes.push({ from: node.type, type: 'operator', value: '|' });\n                return pfNodes;\n              }\n            case '\\\\S':\n              return [{\n                from: node.type,\n                type: 'operand',\n                value: [' ', '\\t', '\\n', '\\r', '\\f', '\\v'],\n                notEqual: true,\n              }];\n            default:\n              throw new Error(`Do not know how to handle: \"${val}\"`);\n          }\n        }\n      case 'anyChar':\n        {\n          return [{ from: node.type, type: 'operand', value: '', notEqual: isNil(notEqual) ? true : !notEqual}];\n        }\n      case 'characterGroup':\n        {\n          // Check if the '^' slot is not empty. This means that the group is an exclusion group.\n          const exclusionGroup = node.value[1].value[0];\n          return _createPostfix(node.value[2], exclusionGroup ? true : undefined);\n        }\n      case 'characterRangeItem':\n        {\n          const start = getValue(node.value[0]);\n          const end = getValue(node.value[2]);\n          const pfNodes: PostfixNode[] = [];\n          return createRangePostfixNodes(node, start, end, pfNodes, notEqual);\n        }\n      default:\n        throw new Error(`Do not know how to handle: \"${node.type}\"`);\n    }\n  };\n\n  return {\n    postfix: _createPostfix(getAST(regex), undefined),\n    hasStartMatcher,\n    hasEndMatcher,\n  };\n}\n\nexport interface State {\n  type: 'Split' | 'Match' | 'Char';\n  notEqual?: boolean;\n  // For `Char` type, this is the character to match.\n  char?: string | string[];\n  // The next state to go to.\n  out: State | null;\n  // For `Split` type, this is the second state to go to.\n  out1: State | null;\n  // This field is used in the NFA stepping algorithm to prevent adding the same state to a list multiple times.\n  lastListID?: number;\n}\n\ninterface FragOutPtr {\n  state: State;\n  outAttr: 'out' | 'out1';\n}\n\ninterface Frag {\n  start: State;\n  out: FragOutPtr[];\n}\n\n/**\n * Patches the NFA fragment with the new state.\n * The dangling pointers are set to the provided state.\n *\n * @param ptrList\n * @param state\n */\nconst patch = (ptrList: FragOutPtr[], state: State) => {\n  each(ptrList, (ptr) => {\n    if (ptr.state[ptr.outAttr] === null) {\n      ptr.state[ptr.outAttr] = state;\n    }\n  });\n}\n\n/**\n * Converts the postfix notation to an NFA.\n *\n * @param postfix\n */\nexport const postfixToNFA = (postfix: PostfixNode[]): State | undefined => {\n  const stack: Frag[] = [];\n\n  each(postfix, (p) => {\n    if (p.type === 'operator') {\n      switch (p.value) {\n        // Concatenation\n        case '.':\n          {\n            const e2 = stack.pop();\n            const e1 = stack.pop();\n            if (!e1 || !e2) {\n              throw new Error('Invalid postfix expression');\n            }\n            patch(e1.out, e2.start);\n            stack.push({ start: e1.start, out: e2.out });\n          }\n          break;\n        // Alternation\n        case '|':\n          {\n            const e2 = stack.pop();\n            const e1 = stack.pop();\n            if (!e1 || !e2) {\n              throw new Error('Invalid postfix expression');\n            }\n            const s: State = { type: 'Split', out: e1.start, out1: e2.start };\n            stack.push({ start: s, out: [...e1.out, ...e2.out] });\n          }\n          break;\n        // Zero or one\n        case '?':\n          {\n            const e = stack.pop();\n            if (!e) {\n              throw new Error('Invalid postfix expression');\n            }\n            const s: State = { type: 'Split', out: e.start, out1: null };\n            stack.push({ start: s, out: [{ state: s, outAttr: 'out1' }, ...e.out] });\n          }\n          break;\n        // Zero or more\n        case '*':\n          {\n            const e = stack.pop();\n            if (!e) {\n              throw new Error('Invalid postfix expression');\n            }\n            const s: State = { type: 'Split', out: e.start, out1: null };\n            patch(e.out, s);\n            stack.push({ start: s, out: [{ state: s, outAttr: 'out1' }] });\n          }\n          break;\n        // One or more\n        case '+':\n          {\n            const e = stack.pop();\n            if (!e) {\n              throw new Error('Invalid postfix expression');\n            }\n            const s: State = { type: 'Split', out: e.start, out1: null };\n            patch(e.out, s);\n            stack.push({ start: e.start, out: [{ state: s, outAttr: 'out1' }] });\n          }\n          break;\n        default:\n          throw new Error(`Unknown operator: ${p.value}`);\n      }\n    } else {\n      const s: State = { type: 'Char', char: p.value, notEqual: p.notEqual, out: null, out1: null };\n      stack.push({ start: s, out: [{ state: s, outAttr: 'out' }] });\n    }\n  });\n\n  // The stack should have only one fragment left.\n  // Patch in the match state.\n  const e = stack.pop();\n  if (!e) {\n    throw new Error('Invalid postfix expression');\n  }\n  patch(e.out, { type: 'Match', out: null, out1: null });\n  \n  return e.start;\n};\n\ninterface MatchOptions {\n  // If true, the algorithm will try to match the longest possible string. If false, it will try to match the shortest possible string.\n  // default: true\n  greedy?: boolean;\n  // If true, the algorithm will try to match all occurrences of the pattern in the input string. If false, it will only try to match the first occurrence.\n  // default: false\n  global?: boolean;\n  // If true, the algorithm will ignore the case of the input string.\n  // default: false\n  ignoreCase?: boolean;\n  // If true, the algorithm will match from the start of the input string.\n  // default: false\n  matchFromStart?: boolean;\n  // If true, the algorithm will match to the end of the input string.\n  // default: false\n  matchToEnd?: boolean;\n  // If provided, the algorithm will replace the matched string with the return value of this function.\n  onReplace?: (val: string) => string;\n  // Size of the highWaterMark for the processing stream.\n  // default: 1024\n  processingStreamHighWaterMark?: number;\n}\n\ninterface _MatchResult {\n  matchedValue: string | undefined;\n  srcValue: string;\n}\n\n/**\n * Runs the NFA on the input string.\n *\n * @param start - The start state of the NFA.\n * @param input - Input stream to match.\n * @param options - Options for the match.\n */\nexport const match = (start: State, input: Readable, options?: MatchOptions) => {\n  // This ID is used to prevent adding the same state to a list multiple times.\n  // We do this by giving each state list a unique ID (listID) and then setting the lastList property of the state to the listID.\n  // If the lastList property of the state is the same as the listID, we skip adding the state to the list.\n  let listID = 1;\n  // Default options.\n  const opts: MatchOptions = {\n    greedy: true,\n    global: false,\n    ignoreCase: false,\n    processingStreamHighWaterMark: 1024,\n    ...options,\n  };\n\n  /**\n   * Adds a state to the list. Handles the split nodes by adding both out and out1 states.\n   *\n   * @param list\n   * @param s\n   */\n  const addState = (list: State[], s: State | null) => {\n    // If the state is null or the lastList property is the same as the listID, skip adding the state to the list.\n    if (s === null || s.lastListID === listID) {\n      return;\n    }\n\n    s.lastListID = listID;\n    // If the state is a split node, add both out and out1 states.\n    if (s.type === 'Split') {\n      addState(list, s.out);\n      addState(list, s.out1);\n      return;\n    }\n    list.push(s);\n  }\n  \n  /**\n   * Runs one step of NFA on the input character.\n   * The output is the next state list.\n   *\n   * @param list\n   * @param char\n   */\n  const step = (list: State[], char: string) => {\n    debugLogger('[step] Step: %o', { listID, char });\n\n    listID++;\n    const nextStates: State[] = [];\n    each(list, (state) => {\n      if (state.type === 'Char' && !isNil(state.char)) {\n        const srcChar = opts.ignoreCase ? char.toLowerCase() : char;\n        const stateCharArray = isArray(state.char) ? state.char : [state.char];\n        const hasMatch = every(stateCharArray, (stateChar) => {\n          const stateCharLower = opts.ignoreCase ? stateChar.toLowerCase() : stateChar;\n          return (state.notEqual ? stateCharLower !== srcChar : stateCharLower === srcChar);\n        });\n        if (hasMatch) {\n          debugLogger('[step] Match: %o', state);\n          addState(nextStates, state.out);\n        } else {\n          debugLogger('[step] No match: %o', state);\n        }\n      }\n    });\n\n    debugLogger('[step] Next states: %o', nextStates);\n    return nextStates;\n  }\n\n  /**\n   * Main function. Runs the NFA on the input stream.\n   *\n   * @param start\n   * @param greedy\n   * @param highWaterMark\n   */\n  const _doMatchStream = (start: State, greedy: boolean, highWaterMark?: number) => {\n    let list: State[] = [];\n\n    let strBuffer = '';\n    let lastMatch: string | undefined = undefined;\n\n    const matchStream = new PassThrough({ readableObjectMode: true, writableHighWaterMark: highWaterMark });\n    matchStream._write = (chunk, encoding, callback) => {\n      const chunkStr = chunk.toString();\n      for (let i = 0; i < chunkStr.length; i++) {\n        const char = chunkStr[i];\n        strBuffer += char;\n\n        if (list.length === 0) {\n          // Start the state list by adding the start state.\n          addState(list, start);\n        }\n\n        // Run one step of the NFA.\n        list = step(list, char);\n\n        // If we have a match, save the match and stop if not greedy.\n        if (some(list, (state) => state.type === 'Match')) {\n          debugLogger('[_doMatchStream] Has match');\n          lastMatch = strBuffer;\n\n          if (!greedy) {\n            matchStream.push({ matchedValue: lastMatch, srcValue: strBuffer });\n            strBuffer = '';\n            list = [];\n            lastMatch = undefined;\n          }\n        }\n\n        // If we have no more states to go to, then there is a mismatch. Exit early.\n        if (list.length === 0) {\n          debugLogger('[_doMatchStream] No match - early exit');\n          matchStream.push({ matchedValue: lastMatch, srcValue: lastMatch ? strBuffer.substring(0, strBuffer.length - 1) : strBuffer });\n          strBuffer = '';\n          list = [];\n          if (lastMatch) {\n            lastMatch = undefined;\n            i--;\n          }\n        }\n      }\n\n      callback();\n    };\n\n    // Flush any pending match.\n    matchStream._final = (callback) => {\n      matchStream.push({ matchedValue: lastMatch, srcValue: strBuffer });\n      callback();\n    }\n\n    return matchStream;\n  };\n\n  /**\n   * Entry point for running the NFA on the input stream. This function progressively matches the input stream.\n   *\n   * @param start\n   * @param input\n   * @param options\n   */\n  const doMatchStream = (start: State, input: Readable, options: MatchOptions) => {\n    // Output stream.\n    const replaceStream = new Readable();\n    // TODO: Respect the highWaterMark.\n    replaceStream._read = () => {};\n\n    // First match success flag.\n    let matchSucceeded = false;\n    // Most recent matched string.\n    let lastMatchedString: string | undefined = undefined;\n    // Reject matching flag.\n    let rejectMatching = false;\n\n    const matchStream = _doMatchStream(start, options.greedy || false, options.processingStreamHighWaterMark);\n    input\n      .pipe(matchStream)\n      .on('data', ({ matchedValue, srcValue }: _MatchResult) => {\n        let str = srcValue;\n\n        if (matchedValue) {\n          // If we're not matching globally, then we're done after the first match.\n          if (!rejectMatching && (options.global || !matchSucceeded)) {\n            if (options.onReplace) {\n              str = options.onReplace(matchedValue);\n            }\n          }\n          // Prevent further matching if we're matching globally.\n          matchSucceeded = true;\n\n          // If we're not matching to the end of stream, push the matched string to the output stream.\n          if (!options.matchToEnd) {\n            replaceStream.push(str)\n          } else if (!rejectMatching) {\n            // Record this match (used for end matching).\n            // The replacement processing is done at the end when the stream is finished. If subsequent chunks are not matched, then we'll need the original source string.\n            // NOTE: `global` has no effect on `matchToEnd`.\n            lastMatchedString = matchedValue;\n          }\n        } else {\n          // Start rejecting future matches after the first non-match if we're matching from the start.\n          rejectMatching = !!options.matchFromStart;\n          // On a non-match, the last matched string is treated as an unmatched string.\n          if (lastMatchedString) {\n            replaceStream.push(lastMatchedString);\n          }\n          replaceStream.push(str);\n          lastMatchedString = undefined;\n        }\n      })\n      .on('finish', () => {\n        // If we're matching to the end of stream, if a match has survived, run the replacement process and push to output.\n        if (options.matchToEnd) {\n          if (lastMatchedString) {\n            replaceStream.push(options.onReplace ? options.onReplace(lastMatchedString) : lastMatchedString);\n          }\n        }\n        replaceStream.push(null);\n      });\n\n    return replaceStream;\n  }\n\n  // Start the NFA.\n  return doMatchStream(start, input, opts);\n};"],"mappings":"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"}