{"version":3,"file":"nfa.js","names":["_stream","require","_debug","_interopRequireDefault","_each","_isNil","_range","_some","_every","_isArray","_reduce","_map","_ast","obj","__esModule","default","debugLogger","debug","createRangePostfixNodes","node","start","end","pfNodes","notEqual","newNodes","each","range","charCodeAt","charCode","push","from","type","value","String","fromCharCode","length","createPostfix","regex","hasEndMatcher","hasStartMatcher","_createPostfix","subExp","idx","expressionItems","expressionItem","getValue","pfNode","reduce","memo","n","quantifier","val","replace","map","Error","isNil","exclusionGroup","undefined","postfix","getAST","exports","patch","ptrList","state","ptr","outAttr","postfixToNFA","stack","p","e2","pop","e1","out","s","out1","e","char","match","input","options","listID","opts","greedy","global","ignoreCase","replaceStream","onReplace","Readable","_read","matchSucceeded","lastMatchedString","rejectMatching","addState","list","lastListID","step","nextStates","srcChar","toLowerCase","stateCharArray","isArray","hasMatch","every","stateChar","stateCharLower","_doMatchStream","onResult","strBuffer","lastMatch","nfaExecuted","on","chunk","startBufferLength","str","toString","some","substring","success","close","createPassThroughStream","onBufferChange","bufferedStr","procStream","PassThrough","newBufferedStr","passThrough","writableEnded","unpipe","pipe","readableEnded","doMatchStream","resv","prom","Promise","resolve","then","matchedStr","origStr","idxOffset","matchToEnd","onMatch","matchFromStart"],"sources":["../src/nfa.ts"],"sourcesContent":["import { Readable, PassThrough } from 'stream';\n\nimport debug from 'debug';\nimport each from 'lodash/each';\nimport isNil from 'lodash/isNil';\nimport range from 'lodash/range';\nimport some from 'lodash/some';\nimport every from 'lodash/every';\nimport isArray from 'lodash/isArray';\nimport reduce from 'lodash/reduce';\nimport map from 'lodash/map';\n\nimport type { AST } from './ast';\nimport { getAST, getValue } from './ast';\n\nconst debugLogger = debug('NFA');\n\nexport interface PostfixNode {\n  from: string;\n  type: string;\n  value: string | string[];\n  notEqual?: boolean;\n}\n\n/**\n * Helper function to construct the postfix notation for a range of characters.\n * TODO: This is inefficient. We should construct the NFA from the range directly instead of creating a node for each character.\n *\n * @param node\n * @param start\n * @param end\n * @param pfNodes\n * @param notEqual\n */\nconst createRangePostfixNodes = (node: AST, start: string, end: string, pfNodes: PostfixNode[], notEqual?: boolean): PostfixNode[] => {\n  const newNodes = [...pfNodes];\n  each(range(start.charCodeAt(0), end.charCodeAt(0) + 1), (charCode) => {\n    newNodes.push({ from: node.type, type: 'operand', value: String.fromCharCode(charCode), notEqual });\n    if (newNodes.length > 1) {\n      newNodes.push({ from: node.type, type: 'operator', value: '|' });\n    }\n  });\n  return newNodes;\n}\n\n/**\n * Converts an AST to postfix notation.\n *\n * @param regex\n */\nexport const createPostfix = (regex: RegExp) => {\n  let hasEndMatcher = false;\n  let hasStartMatcher = false;\n\n  /**\n   * Recursively creates the postfix notation.\n   *\n   * @param node\n   * @param notEqual - If true, the node character value is matched against any character except the one specified.\n   */\n  const _createPostfix = (node: AST, notEqual: boolean | undefined): PostfixNode[] => {\n    switch (node.type) {\n      case 'expression':\n        {\n          hasStartMatcher = node.value[0].value.length !== 0;\n          const pfNodes: PostfixNode[] = [];\n          each([node.value[1], ...node.value[3].value], (subExp, idx) => {\n            pfNodes.push(..._createPostfix(subExp, notEqual));\n            if (idx > 0 && idx <= node.value[3].value.length) {\n              pfNodes.push({ from: node.type, type: 'operator', value: '|' });\n            }\n          });\n          return pfNodes;\n        }\n      case 'subExpression':\n        {\n          // This node is an iteration list. Unroll.\n          const expressionItems = node.value[0].value;\n          const pfNodes: PostfixNode[] = [];\n          each(expressionItems, (expressionItem, idx) => {\n            hasEndMatcher = getValue(expressionItem) === '$';\n            if (hasEndMatcher) {\n              return false;\n            }\n            pfNodes.push(..._createPostfix(expressionItem, notEqual));\n            if (idx > 0 && idx < expressionItems.length) {\n              pfNodes.push({ from: node.type, type: 'operator', value: '.' });\n            }\n          });\n          return pfNodes;\n        }\n      case 'characterGroupInner':\n        {\n          // This node is an iteration list. Unroll.\n          const expressionItems = node.value[0].value;\n          const pfNodes: PostfixNode[] = [];\n          each(expressionItems, (expressionItem, idx) => {\n            // Character groups with the '^' exclusion character need to have have all characters in a single node.\n            if (!notEqual) {\n              pfNodes.push(..._createPostfix(expressionItem, notEqual));\n            } else {\n              const pfNode: PostfixNode = reduce(_createPostfix(expressionItem, notEqual), (memo, n) => ({\n                ...memo,\n                value: [...memo.value, ...n.value],\n              }), {\n                from: node.type,\n                type: 'operand',\n                value: [] as string[],\n                notEqual,\n              });\n              if (idx === 0) {\n                pfNodes.push(pfNode);\n              } else {\n                pfNodes[0].value = [...pfNodes[0].value, ...pfNode.value];\n              }\n            }\n\n            // Character groups without the '^' exclusion character need to have an OR operator between each character.\n            if (!notEqual && idx > 0 && idx < expressionItems.length) {\n              pfNodes.push({ from: node.type, type: 'operator', value: '|' });\n            }\n          });\n          return pfNodes;\n        }\n      case 'expressionItem':\n      case 'matchCharacterClass':\n      case 'characterGroupItem':\n      case 'characterRange':\n      case 'matchItem':\n      case 'group':\n        {\n          // Should have only one child.\n          return _createPostfix(node.value[0], notEqual);\n        }\n      case 'groupExpression':\n        {\n          const quantifier = getValue(node.value[4]);\n          return [\n            ..._createPostfix(node.value[2], notEqual),\n            ...(quantifier ? [{ from: node.type, type: 'operator', value: quantifier }] : []),\n          ];\n        }\n      case 'match':\n        {\n          const quantifier = getValue(node.value[1]);\n          return [\n            ..._createPostfix(node.value[0], notEqual),\n            ...(quantifier ? [{ from: node.type, type: 'operator', value: quantifier }] : []),\n          ];\n        }\n      case 'character':\n      case 'characterClass':\n        {\n          let val = getValue(node);\n          if (node.type !== 'characterClass') {\n            val = val.replace(/^\\\\/, '');\n            return [{ from: node.type, type: 'operand', value: val, notEqual }];\n          }\n          switch (val) {\n           case '\\\\w':\n            {\n              let pfNodes: PostfixNode[] = [];\n              pfNodes = createRangePostfixNodes(node, 'a', 'z', pfNodes, notEqual);\n              pfNodes = createRangePostfixNodes(node, 'A', 'Z', pfNodes, notEqual);\n              pfNodes = createRangePostfixNodes(node, '0', '9', pfNodes, notEqual);\n              pfNodes.push({ from: node.type, type: 'operand', value: '_', notEqual: notEqual });\n              pfNodes.push({ from: node.type, type: 'operator', value: '|' });\n              return pfNodes;\n            }\n            case '\\\\W':\n              return [{\n                from: node.type,\n                type: 'operand',\n                value: map([\n                  ...range('a'.charCodeAt(0), 'z'.charCodeAt(0) + 1),\n                  ...range('A'.charCodeAt(0), 'Z'.charCodeAt(0) + 1),\n                  ...range('0'.charCodeAt(0), '9'.charCodeAt(0) + 1),\n                  '_'.charCodeAt(0),\n                ], (charCode) => String.fromCharCode(charCode)),\n                notEqual: true,\n              }];\n            case '\\\\d':\n              return createRangePostfixNodes(node, '0', '9', [], notEqual);\n            case '\\\\D':\n              return [{\n                from: node.type,\n                type: 'operand',\n                value: map(range('0'.charCodeAt(0), '9'.charCodeAt(0) + 1), (charCode) => String.fromCharCode(charCode)),\n                notEqual: true,\n              }];\n            case '\\\\s':\n              {\n                const pfNodes: PostfixNode[] = [];\n                pfNodes.push({ from: node.type, type: 'operand', value: ' ', notEqual: notEqual });\n                pfNodes.push({ from: node.type, type: 'operand', value: '\\t', notEqual: notEqual });\n                pfNodes.push({ from: node.type, type: 'operator', value: '|' });\n                pfNodes.push({ from: node.type, type: 'operand', value: '\\n', notEqual: notEqual });\n                pfNodes.push({ from: node.type, type: 'operator', value: '|' });\n                pfNodes.push({ from: node.type, type: 'operand', value: '\\r', notEqual: notEqual });\n                pfNodes.push({ from: node.type, type: 'operator', value: '|' });\n                pfNodes.push({ from: node.type, type: 'operand', value: '\\f', notEqual: notEqual });\n                pfNodes.push({ from: node.type, type: 'operator', value: '|' });\n                pfNodes.push({ from: node.type, type: 'operand', value: '\\v', notEqual: notEqual });\n                pfNodes.push({ from: node.type, type: 'operator', value: '|' });\n                return pfNodes;\n              }\n            case '\\\\S':\n              return [{\n                from: node.type,\n                type: 'operand',\n                value: [' ', '\\t', '\\n', '\\r', '\\f', '\\v'],\n                notEqual: true,\n              }];\n            default:\n              throw new Error(`Do not know how to handle: \"${val}\"`);\n          }\n        }\n      case 'anyChar':\n        {\n          return [{ from: node.type, type: 'operand', value: '', notEqual: isNil(notEqual) ? true : !notEqual}];\n        }\n      case 'characterGroup':\n        {\n          // Check if the '^' slot is not empty. This means that the group is an exclusion group.\n          const exclusionGroup = node.value[1].value[0];\n          return _createPostfix(node.value[2], exclusionGroup ? true : undefined);\n        }\n      case 'characterRangeItem':\n        {\n          const start = getValue(node.value[0]);\n          const end = getValue(node.value[2]);\n          const pfNodes: PostfixNode[] = [];\n          return createRangePostfixNodes(node, start, end, pfNodes, notEqual);\n        }\n      default:\n        throw new Error(`Do not know how to handle: \"${node.type}\"`);\n    }\n  };\n\n  return {\n    postfix: _createPostfix(getAST(regex), undefined),\n    hasStartMatcher,\n    hasEndMatcher,\n  };\n}\n\nexport interface State {\n  type: 'Split' | 'Match' | 'Char';\n  notEqual?: boolean;\n  // For `Char` type, this is the character to match.\n  char?: string | string[];\n  // The next state to go to.\n  out: State | null;\n  // For `Split` type, this is the second state to go to.\n  out1: State | null;\n  // This field is used in the NFA stepping algorithm to prevent adding the same state to a list multiple times.\n  lastListID?: number;\n}\n\ninterface FragOutPtr {\n  state: State;\n  outAttr: 'out' | 'out1';\n}\n\ninterface Frag {\n  start: State;\n  out: FragOutPtr[];\n}\n\n/**\n * Patches the NFA fragment with the new state.\n * The dangling pointers are set to the provided state.\n *\n * @param ptrList\n * @param state\n */\nconst patch = (ptrList: FragOutPtr[], state: State) => {\n  each(ptrList, (ptr) => {\n    if (ptr.state[ptr.outAttr] === null) {\n      ptr.state[ptr.outAttr] = state;\n    }\n  });\n}\n\n/**\n * Converts the postfix notation to an NFA.\n *\n * @param postfix\n */\nexport const postfixToNFA = (postfix: PostfixNode[]): State | undefined => {\n  const stack: Frag[] = [];\n\n  each(postfix, (p) => {\n    if (p.type === 'operator') {\n      switch (p.value) {\n        // Concatenation\n        case '.':\n          {\n            const e2 = stack.pop();\n            const e1 = stack.pop();\n            if (!e1 || !e2) {\n              throw new Error('Invalid postfix expression');\n            }\n            patch(e1.out, e2.start);\n            stack.push({ start: e1.start, out: e2.out });\n          }\n          break;\n        // Alternation\n        case '|':\n          {\n            const e2 = stack.pop();\n            const e1 = stack.pop();\n            if (!e1 || !e2) {\n              throw new Error('Invalid postfix expression');\n            }\n            const s: State = { type: 'Split', out: e1.start, out1: e2.start };\n            stack.push({ start: s, out: [...e1.out, ...e2.out] });\n          }\n          break;\n        // Zero or one\n        case '?':\n          {\n            const e = stack.pop();\n            if (!e) {\n              throw new Error('Invalid postfix expression');\n            }\n            const s: State = { type: 'Split', out: e.start, out1: null };\n            stack.push({ start: s, out: [{ state: s, outAttr: 'out1' }, ...e.out] });\n          }\n          break;\n        // Zero or more\n        case '*':\n          {\n            const e = stack.pop();\n            if (!e) {\n              throw new Error('Invalid postfix expression');\n            }\n            const s: State = { type: 'Split', out: e.start, out1: null };\n            patch(e.out, s);\n            stack.push({ start: s, out: [{ state: s, outAttr: 'out1' }] });\n          }\n          break;\n        // One or more\n        case '+':\n          {\n            const e = stack.pop();\n            if (!e) {\n              throw new Error('Invalid postfix expression');\n            }\n            const s: State = { type: 'Split', out: e.start, out1: null };\n            patch(e.out, s);\n            stack.push({ start: e.start, out: [{ state: s, outAttr: 'out1' }] });\n          }\n          break;\n        default:\n          throw new Error(`Unknown operator: ${p.value}`);\n      }\n    } else {\n      const s: State = { type: 'Char', char: p.value, notEqual: p.notEqual, out: null, out1: null };\n      stack.push({ start: s, out: [{ state: s, outAttr: 'out' }] });\n    }\n  });\n\n  // The stack should have only one fragment left.\n  // Patch in the match state.\n  const e = stack.pop();\n  if (!e) {\n    throw new Error('Invalid postfix expression');\n  }\n  patch(e.out, { type: 'Match', out: null, out1: null });\n  \n  return e.start;\n};\n\ninterface MatchOptions {\n  // If true, the algorithm will try to match the longest possible string. If false, it will try to match the shortest possible string.\n  // default: true\n  greedy?: boolean;\n  // If true, the algorithm will try to match all occurrences of the pattern in the input string. If false, it will only try to match the first occurrence.\n  // default: false\n  global?: boolean;\n  // If true, the algorithm will ignore the case of the input string.\n  ignoreCase?: boolean;\n  // If true, the algorithm will match from the start of the input string.\n  matchFromStart?: boolean;\n  // If true, the algorithm will match to the end of the input string.\n  matchToEnd?: boolean;\n  // Callback that is called when a match is found.\n  onMatch?: (val: string) => void;\n  // If provided, the algorithm will replace the matched string with the return value of this function.\n  onReplace?: (val: string) => string;\n}\n\n/**\n * Runs the NFA on the input string.\n *\n * @param start - The start state of the NFA.\n * @param input - Input stream to match.\n * @param options - Options for the match.\n */\nexport const match = (start: State, input: Readable, options?: MatchOptions) => {\n  // This ID is used to prevent adding the same state to a list multiple times.\n  // We do this by giving each state list a unique ID (listID) and then setting the lastList property of the state to the listID.\n  // If the lastList property of the state is the same as the listID, we skip adding the state to the list.\n  let listID = 1;\n  // Default options.\n  const opts = {\n    greedy: true,\n    global: false,\n    ignoreCase: false,\n    ...options,\n  };\n  // Output stream\n  const replaceStream = opts.onReplace ? new Readable() : undefined;\n  if (replaceStream) {\n    replaceStream._read = () => {};\n  }\n  // First match success flag.\n  let matchSucceeded = false;\n  // Most recent matched string.\n  let lastMatchedString: string | undefined = undefined;\n  // Reject matching flag.\n  let rejectMatching = false;\n\n  /**\n   * Adds a state to the list. Handles the split nodes by adding both out and out1 states.\n   *\n   * @param list\n   * @param s\n   */\n  const addState = (list: State[], s: State | null) => {\n    // If the state is null or the lastList property is the same as the listID, skip adding the state to the list.\n    if (s === null || s.lastListID === listID) {\n      return;\n    }\n\n    s.lastListID = listID;\n    // If the state is a split node, add both out and out1 states.\n    if (s.type === 'Split') {\n      addState(list, s.out);\n      addState(list, s.out1);\n      return;\n    }\n    list.push(s);\n  }\n  \n  /**\n   * Runs one step of NFA on the input character.\n   * The output is the next state list.\n   *\n   * @param list\n   * @param char\n   */\n  const step = (list: State[], char: string) => {\n    debugLogger('[step] Step: %o', { listID, char });\n\n    listID++;\n    const nextStates: State[] = [];\n    each(list, (state) => {\n      if (state.type === 'Char' && state.char) {\n        const srcChar = opts.ignoreCase ? char.toLowerCase() : char;\n        const stateCharArray = isArray(state.char) ? state.char : [state.char];\n        const hasMatch = every(stateCharArray, (stateChar) => {\n          const stateCharLower = opts.ignoreCase ? stateChar.toLowerCase() : stateChar;\n          return (state.notEqual ? stateCharLower !== srcChar : stateCharLower === srcChar);\n        });\n        if (hasMatch) {\n          debugLogger('[step] Match: %o', state);\n          addState(nextStates, state.out);\n        } else {\n          debugLogger('[step] No match: %o', state);\n        }\n      }\n    });\n\n    debugLogger('[step] Next states: %o', nextStates);\n    return nextStates;\n  }\n\n  /**\n   * Main function. Runs the NFA on the input stream.\n   *\n   * @param start\n   * @param input\n   * @param greedy\n   * @param onResult\n   */\n  const _doMatchStream = (start: State, input: PassThrough, greedy: boolean, onResult: (res: { success: boolean; val?: string; close: boolean; }) => void) => {\n    // Start the state list by adding the start state.\n    let list: State[] = [];\n    addState(list, start);\n\n    let strBuffer = '';\n    let lastMatch: string | undefined = undefined;\n    let nfaExecuted = false;\n\n    input.on('data', (chunk) => {\n      const startBufferLength = strBuffer.length;\n      const str: string = chunk.toString();\n      strBuffer += str;\n\n      // Run the steps.\n      each(str, (char, idx) => {\n        nfaExecuted = true;\n        // One step.\n        list = step(list, char);\n\n        // If we have a match, save the match and stop if not greedy.\n        if (some(list, (state) => state.type === 'Match')) {\n          debugLogger('[_doMatchStream] Has match');\n          lastMatch = strBuffer.substring(0, startBufferLength + idx + 1);\n          if (!greedy) {\n            input.end();\n            return false;\n          }\n        }\n\n        // If we have no more states to go to, then there is a mismatch. Exit early.\n        if (list.length === 0) {\n          debugLogger('[_doMatchStream] No match - early exit');\n          input.end();\n          return false;\n        }\n      });\n    });\n    input.on('close', () => {\n      debugLogger('[_doMatchStream] input stream closed: %o', lastMatch);\n      onResult({ success: !!lastMatch, val: lastMatch, close: !nfaExecuted });\n    });\n    input.on('end', () => {\n      debugLogger('[_doMatchStream] input stream ended: %o', lastMatch);\n      onResult({ success: !!lastMatch, val: lastMatch, close: !nfaExecuted });\n    });\n  };\n\n  /**\n   * Creates a processing stream that buffers the string from the input stream, such that we can run the NFA on it.\n   *\n   * @param input - The input stream.\n   * @param onBufferChange - Callback that is called when the buffered string is updated.\n   * @param idx - The index to start buffering from.\n   * @param bufferedStr - The previously buffered string.\n   */\n  const createPassThroughStream = (input: Readable, onBufferChange: (newBufferedStr: string) => void, idx = 0, bufferedStr = '') => {\n    const procStream = new PassThrough();\n    procStream.push(bufferedStr.substring(idx));\n\n    let newBufferedStr = bufferedStr;\n    const passThrough = new PassThrough();\n    passThrough.on('data', (chunk) => {\n      const str: string = chunk.toString();\n      newBufferedStr += str;\n      onBufferChange(newBufferedStr);\n\n      if (!procStream.writableEnded) {\n        procStream.push(str);\n      } else {\n        input.unpipe(passThrough);\n      }\n    }).on('end', () => {\n      debugLogger('[createPassThroughStream] passThrough stream ended');\n      procStream.end();\n    });\n    procStream.on('end', () => {\n      debugLogger('[createPassThroughStream] procStream ended');\n      passThrough.end();\n    });\n\n    input.pipe(passThrough);\n    if (input.readableEnded) {\n      debugLogger('[createPassThroughStream] input stream already ended');\n      procStream.end();\n    }\n\n    return procStream;\n  }\n\n  /**\n   * Entry point for running the NFA on the input stream. This function progressively matches the input stream.\n   *\n   * @param start\n   * @param input\n   * @param options\n   * @param idx\n   * @param bufferedStr\n   */\n  const doMatchStream = (start: State, input: Readable, options: MatchOptions, idx = 0, bufferedStr = '') => {\n    let strBuffer = bufferedStr;\n    const procStream = createPassThroughStream(input, (newBufferedStr) => { strBuffer = newBufferedStr; }, idx, strBuffer);\n\n    let resv: (res: { val?: string; close: boolean }) => void;\n    const prom = new Promise<{ val?: string; close: boolean }>((resolve) => { resv = resolve; });\n\n    _doMatchStream(start, procStream, options.greedy || false, ({ success, val, close }) => {\n      debugLogger('[doMatchStream] match result: %o', { success, val });\n      if (success && !val) {\n        // This should not happen.\n        throw new Error('Invalid state');\n      }\n      resv({ val, close });\n    });\n\n    prom.then(({ val: matchedStr, close }) => {\n      procStream.end();\n\n      debugLogger('[doMatchStream] processing result: %o', { matchedStr, strBuffer, idx });\n\n      const origStr = strBuffer.substring(idx, idx + 1);\n      let str = origStr;\n      let idxOffset = 1;\n\n      if (matchedStr) {\n        idxOffset = matchedStr.length;\n        str = matchedStr;\n\n        // If we're not matching globally, then we're done after the first match.\n        if (!rejectMatching && (options.global || !matchSucceeded)) {\n          if (options.onReplace) {\n            str = options.onReplace(matchedStr);\n          }\n\n          // If we're not matching to the end of stream, call the onMatch callback.\n          if (!options.matchToEnd) {\n            options.onMatch?.(matchedStr);\n          }\n        }\n        // If we're not matching to the end of stream, push the matched string to the output stream.\n        if (!options.matchToEnd) {\n          replaceStream?.push(str)\n        }\n\n        // Record this match (used for end matching).\n        if (!rejectMatching) {\n          lastMatchedString = matchedStr;\n        } else {\n          lastMatchedString = `${lastMatchedString || ''}${matchedStr}`;\n        }\n\n        matchSucceeded = true;\n      } else {\n        if (!close) {\n          rejectMatching = !!options.matchFromStart;\n        }\n        if (!options.matchToEnd) {\n          replaceStream?.push(origStr);\n        } else if (!close) {\n          if (lastMatchedString) {\n            replaceStream?.push(lastMatchedString);\n          }\n          replaceStream?.push(origStr);\n          lastMatchedString = undefined;\n        }\n      }\n\n      if (idx + idxOffset <= strBuffer.length) {\n        doMatchStream(start, input, options, idx + idxOffset, strBuffer);\n      } else {\n        if (options.matchToEnd) {\n          if (lastMatchedString) {\n            options.onMatch?.(lastMatchedString);\n            replaceStream?.push(!rejectMatching && options.onReplace ? options.onReplace(lastMatchedString) : lastMatchedString);\n          }\n        }\n        replaceStream?.push(null);\n      }\n    });\n\n    return replaceStream;\n  }\n\n  // Start the NFA.\n  return doMatchStream(start, input, opts);\n};"],"mappings":"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"}