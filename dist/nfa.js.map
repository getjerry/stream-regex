{"version":3,"file":"nfa.js","names":["_stream","require","_debug","_interopRequireDefault","_graphemer","_each","_isNil","_range","_some","_every","_isArray","_reduce","_map","_ast","obj","__esModule","default","debugLogger","debug","createRangePostfixNodes","node","start","end","pfNodes","notEqual","newNodes","each","range","charCodeAt","charCode","push","from","type","value","String","fromCharCode","length","createPostfixNodesWithQuantifier","operands","quantifier","minStr","maxStr","isArray","Error","min","parseInt","max","pushCount","res","createPostfix","regex","hasEndMatcher","hasStartMatcher","_createPostfix","subExp","idx","expressionItems","expressionItem","getValue","pfNode","reduce","memo","n","count","val","replace","map","isNil","exclusionGroup","undefined","postfix","getAST","exports","patch","ptrList","state","ptr","outAttr","postfixToNFA","stack","p","e2","pop","e1","out","s","out1","e","char","match","input","options","listID","opts","greedy","global","ignoreCase","processingStreamHighWaterMark","addState","list","lastListID","step","grapheme","nextStates","srcGrapheme","toLowerCase","stateCharArray","hasMatch","every","stateChar","stateGrapheme","_doMatchStream","highWaterMark","strBuffer","lastMatch","lastMatchEnd","splitter","Graphemer","matchStream","PassThrough","readableObjectMode","writableHighWaterMark","_write","chunk","encoding","callback","chunkStr","toString","graphemes","splitGraphemes","some","matchedValue","srcValue","substring","_final","doMatchStream","replaceStream","Readable","_read","matchSucceeded","lastMatchedString","rejectMatching","pipe","on","str","onReplace","matchToEnd","matchFromStart"],"sources":["../src/nfa.ts"],"sourcesContent":["import { PassThrough, Readable } from 'stream';\n\nimport debug from 'debug';\nimport Graphemer from 'graphemer';\nimport each from 'lodash/each';\nimport isNil from 'lodash/isNil';\nimport range from 'lodash/range';\nimport some from 'lodash/some';\nimport every from 'lodash/every';\nimport isArray from 'lodash/isArray';\nimport reduce from 'lodash/reduce';\nimport map from 'lodash/map';\n\nimport type { AST } from './ast';\nimport { getAST, getValue } from './ast';\n\nconst debugLogger = debug('NFA');\n\nexport interface PostfixNode {\n  from: string;\n  type: string;\n  value: string | string[];\n  notEqual?: boolean;\n}\n\n/**\n * Helper function to construct the postfix notation for a range of characters.\n * TODO: This is inefficient. We should construct the NFA from the range directly instead of creating a node for each character.\n *\n * @param node\n * @param start\n * @param end\n * @param pfNodes\n * @param notEqual\n */\nconst createRangePostfixNodes = (\n  node: AST,\n  start: string,\n  end: string,\n  pfNodes: PostfixNode[],\n  notEqual?: boolean,\n): PostfixNode[] => {\n  const newNodes = [...pfNodes];\n  each(range(start.charCodeAt(0), end.charCodeAt(0) + 1), (charCode) => {\n    newNodes.push({\n      from: node.type,\n      type: 'operand',\n      value: String.fromCharCode(charCode),\n      notEqual,\n    });\n    if (newNodes.length > 1) {\n      newNodes.push({ from: node.type, type: 'operator', value: '|' });\n    }\n  });\n  return newNodes;\n};\n\nconst createPostfixNodesWithQuantifier = (\n  operands: PostfixNode[],\n  quantifier: PostfixNode[],\n): PostfixNode[] => {\n  // Single character quantifier (`?` or `*` or `+`)\n  if (quantifier.length <= 1) {\n    return [...operands, ...quantifier];\n  }\n  // Range quantifier (`{m,n}`)\n  const minStr = quantifier[0].value;\n  const maxStr = quantifier[1].value;\n  if (isArray(minStr) || isArray(maxStr)) {\n    throw new Error(`Invalid quantifier: ${minStr} - ${maxStr}`);\n  }\n\n  const min = minStr ? parseInt(minStr, 10) : 0;\n  const max = maxStr ? parseInt(maxStr, 10) : -1;\n  if (max !== -1 && max < min) {\n    throw new Error(`Invalid quantifier: ${min} - ${max}`);\n  }\n\n  // To handle the `min`, we concatenate the operands `min` times.\n  let pushCount = 0;\n  const res: PostfixNode[] = [];\n  each(range(0, min), () => {\n    res.push(...operands);\n    pushCount++;\n    if (pushCount > 1) {\n      res.push({ from: 'quantifier', type: 'operator', value: '.' });\n    }\n  });\n\n  // If max is not specified (i.e. -1), then we match 0 or more times.\n  if (max === -1) {\n    res.push(...operands);\n    res.push({ from: 'quantifier', type: 'operator', value: '*' });\n    pushCount++;\n    if (pushCount > 1) {\n      res.push({ from: 'quantifier', type: 'operator', value: '.' });\n    }\n  } else {\n    // To handle the `max`, we add the operands \"optionally\" `max - min` times.\n    each(range(min, max), () => {\n      res.push(...operands);\n      res.push({ from: 'quantifier', type: 'operator', value: '?' });\n      pushCount++;\n      if (pushCount > 1) {\n        res.push({ from: 'quantifier', type: 'operator', value: '.' });\n      }\n    });\n  }\n\n  return res;\n};\n\n/**\n * Converts an AST to postfix notation.\n *\n * @param regex\n */\nexport const createPostfix = (regex: RegExp) => {\n  let hasEndMatcher = false;\n  let hasStartMatcher = false;\n\n  /**\n   * Recursively creates the postfix notation.\n   *\n   * @param node\n   * @param notEqual - If true, the node character value is matched against any character except the one specified.\n   */\n  const _createPostfix = (\n    node: AST,\n    notEqual: boolean | undefined,\n  ): PostfixNode[] => {\n    switch (node.type) {\n      case 'expression': {\n        hasStartMatcher = node.value[0].value.length !== 0;\n        const pfNodes: PostfixNode[] = [];\n        each([node.value[1], ...node.value[3].value], (subExp, idx) => {\n          pfNodes.push(..._createPostfix(subExp, notEqual));\n          if (idx > 0 && idx <= node.value[3].value.length) {\n            pfNodes.push({ from: node.type, type: 'operator', value: '|' });\n          }\n        });\n        return pfNodes;\n      }\n      case 'subExpression': {\n        // This node is an iteration list. Unroll.\n        const expressionItems = node.value[0].value;\n        const pfNodes: PostfixNode[] = [];\n        each(expressionItems, (expressionItem, idx) => {\n          hasEndMatcher = getValue(expressionItem) === '$';\n          if (hasEndMatcher) {\n            return false;\n          }\n          pfNodes.push(..._createPostfix(expressionItem, notEqual));\n          if (idx > 0 && idx < expressionItems.length) {\n            pfNodes.push({ from: node.type, type: 'operator', value: '.' });\n          }\n        });\n        return pfNodes;\n      }\n      case 'characterGroupInner': {\n        // This node is an iteration list. Unroll.\n        const expressionItems = node.value[0].value;\n        const pfNodes: PostfixNode[] = [];\n        each(expressionItems, (expressionItem, idx) => {\n          // Character groups with the '^' exclusion character need to have have all characters in a single node.\n          if (!notEqual) {\n            pfNodes.push(..._createPostfix(expressionItem, notEqual));\n          } else {\n            const pfNode: PostfixNode = reduce(\n              _createPostfix(expressionItem, notEqual),\n              (memo, n) => ({\n                ...memo,\n                value: [...memo.value, ...n.value],\n              }),\n              {\n                from: node.type,\n                type: 'operand',\n                value: [] as string[],\n                notEqual,\n              },\n            );\n            if (idx === 0) {\n              pfNodes.push(pfNode);\n            } else {\n              pfNodes[0].value = [...pfNodes[0].value, ...pfNode.value];\n            }\n          }\n\n          // Character groups without the '^' exclusion character need to have an OR operator between each character.\n          if (!notEqual && idx > 0 && idx < expressionItems.length) {\n            pfNodes.push({ from: node.type, type: 'operator', value: '|' });\n          }\n        });\n        return pfNodes;\n      }\n      case 'expressionItem':\n      case 'matchCharacterClass':\n      case 'characterGroupItem':\n      case 'characterRange':\n      case 'matchItem':\n      case 'group': {\n        // Should have only one child.\n        return _createPostfix(node.value[0], notEqual);\n      }\n      case 'groupExpression': {\n        const quantifier = node.value[4].value.length\n          ? _createPostfix(node.value[4].value[0], notEqual)\n          : [];\n        const operands = _createPostfix(node.value[2], notEqual);\n        return createPostfixNodesWithQuantifier(operands, quantifier);\n        // return [\n        //   ..._createPostfix(node.value[2], notEqual),\n        //   ...(quantifier ? [{ from: node.type, type: 'operator', value: quantifier }] : []),\n        // ];\n      }\n      case 'match': {\n        const quantifier = node.value[1].value.length\n          ? _createPostfix(node.value[1].value[0], notEqual)\n          : [];\n        const operands = _createPostfix(node.value[0], notEqual);\n        return createPostfixNodesWithQuantifier(operands, quantifier);\n        // return [\n        //   ..._createPostfix(node.value[0], notEqual),\n        //   ...(quantifier ? [{ from: node.type, type: 'operator', value: quantifier }] : []),\n        // ];\n      }\n      case 'quantifier':\n        return _createPostfix(node.value[0], notEqual);\n      case 'quantifierType':\n        if (node.value.length === 0) {\n          return [];\n        }\n        if (node.value[0].value.length === 1) {\n          return [{ from: node.type, type: 'operator', value: getValue(node) }];\n        }\n        return _createPostfix(node.value[0], notEqual);\n      case 'matchCount1': {\n        const count = getValue(node.value[1]);\n        return [\n          { from: node.type, type: 'operator', value: count },\n          {\n            from: node.type,\n            type: 'operator',\n            value: count,\n          },\n        ];\n      }\n      case 'matchCount2':\n        return [\n          { from: node.type, type: 'operator', value: getValue(node.value[1]) },\n          {\n            from: node.type,\n            type: 'operator',\n            value: getValue(node.value[3]),\n          },\n        ];\n      case 'character':\n      case 'characterClass': {\n        let val = getValue(node);\n        if (node.type !== 'characterClass') {\n          val = val.replace(/^\\\\/, '');\n          return [{ from: node.type, type: 'operand', value: val, notEqual }];\n        }\n        switch (val) {\n          case '\\\\w': {\n            let pfNodes: PostfixNode[] = [];\n            pfNodes = createRangePostfixNodes(\n              node,\n              'a',\n              'z',\n              pfNodes,\n              notEqual,\n            );\n            pfNodes = createRangePostfixNodes(\n              node,\n              'A',\n              'Z',\n              pfNodes,\n              notEqual,\n            );\n            pfNodes = createRangePostfixNodes(\n              node,\n              '0',\n              '9',\n              pfNodes,\n              notEqual,\n            );\n            pfNodes.push({\n              from: node.type,\n              type: 'operand',\n              value: '_',\n              notEqual: notEqual,\n            });\n            pfNodes.push({ from: node.type, type: 'operator', value: '|' });\n            return pfNodes;\n          }\n          case '\\\\W':\n            return [\n              {\n                from: node.type,\n                type: 'operand',\n                value: map(\n                  [\n                    ...range('a'.charCodeAt(0), 'z'.charCodeAt(0) + 1),\n                    ...range('A'.charCodeAt(0), 'Z'.charCodeAt(0) + 1),\n                    ...range('0'.charCodeAt(0), '9'.charCodeAt(0) + 1),\n                    '_'.charCodeAt(0),\n                  ],\n                  (charCode) => String.fromCharCode(charCode),\n                ),\n                notEqual: true,\n              },\n            ];\n          case '\\\\d':\n            return createRangePostfixNodes(node, '0', '9', [], notEqual);\n          case '\\\\D':\n            return [\n              {\n                from: node.type,\n                type: 'operand',\n                value: map(\n                  range('0'.charCodeAt(0), '9'.charCodeAt(0) + 1),\n                  (charCode) => String.fromCharCode(charCode),\n                ),\n                notEqual: true,\n              },\n            ];\n          case '\\\\s': {\n            const pfNodes: PostfixNode[] = [];\n            pfNodes.push({\n              from: node.type,\n              type: 'operand',\n              value: ' ',\n              notEqual: notEqual,\n            });\n            pfNodes.push({\n              from: node.type,\n              type: 'operand',\n              value: '\\t',\n              notEqual: notEqual,\n            });\n            pfNodes.push({ from: node.type, type: 'operator', value: '|' });\n            pfNodes.push({\n              from: node.type,\n              type: 'operand',\n              value: '\\n',\n              notEqual: notEqual,\n            });\n            pfNodes.push({ from: node.type, type: 'operator', value: '|' });\n            pfNodes.push({\n              from: node.type,\n              type: 'operand',\n              value: '\\r',\n              notEqual: notEqual,\n            });\n            pfNodes.push({ from: node.type, type: 'operator', value: '|' });\n            pfNodes.push({\n              from: node.type,\n              type: 'operand',\n              value: '\\f',\n              notEqual: notEqual,\n            });\n            pfNodes.push({ from: node.type, type: 'operator', value: '|' });\n            pfNodes.push({\n              from: node.type,\n              type: 'operand',\n              value: '\\v',\n              notEqual: notEqual,\n            });\n            pfNodes.push({ from: node.type, type: 'operator', value: '|' });\n            return pfNodes;\n          }\n          case '\\\\S':\n            return [\n              {\n                from: node.type,\n                type: 'operand',\n                value: [' ', '\\t', '\\n', '\\r', '\\f', '\\v'],\n                notEqual: true,\n              },\n            ];\n          default:\n            throw new Error(`Do not know how to handle: \"${val}\"`);\n        }\n      }\n      case 'anyChar': {\n        return [\n          {\n            from: node.type,\n            type: 'operand',\n            value: '',\n            notEqual: isNil(notEqual) ? true : !notEqual,\n          },\n        ];\n      }\n      case 'characterGroup': {\n        // Check if the '^' slot is not empty. This means that the group is an exclusion group.\n        const exclusionGroup = node.value[1].value[0];\n        return _createPostfix(node.value[2], exclusionGroup ? true : undefined);\n      }\n      case 'characterRangeItem': {\n        const start = getValue(node.value[0]);\n        const end = getValue(node.value[2]);\n        const pfNodes: PostfixNode[] = [];\n        return createRangePostfixNodes(node, start, end, pfNodes, notEqual);\n      }\n      default:\n        throw new Error(`Do not know how to handle: \"${node.type}\"`);\n    }\n  };\n\n  return {\n    postfix: _createPostfix(getAST(regex), undefined),\n    hasStartMatcher,\n    hasEndMatcher,\n  };\n};\n\nexport interface State {\n  type: 'Split' | 'Match' | 'Char';\n  notEqual?: boolean;\n  // For `Char` type, this is the character to match.\n  char?: string | string[];\n  // The next state to go to.\n  out: State | null;\n  // For `Split` type, this is the second state to go to.\n  out1: State | null;\n  // This field is used in the NFA stepping algorithm to prevent adding the same state to a list multiple times.\n  lastListID?: number;\n}\n\ninterface FragOutPtr {\n  state: State;\n  outAttr: 'out' | 'out1';\n}\n\ninterface Frag {\n  start: State;\n  out: FragOutPtr[];\n}\n\n/**\n * Patches the NFA fragment with the new state.\n * The dangling pointers are set to the provided state.\n *\n * @param ptrList\n * @param state\n */\nconst patch = (ptrList: FragOutPtr[], state: State) => {\n  each(ptrList, (ptr) => {\n    if (ptr.state[ptr.outAttr] === null) {\n      ptr.state[ptr.outAttr] = state;\n    }\n  });\n};\n\n/**\n * Converts the postfix notation to an NFA.\n *\n * @param postfix\n */\nexport const postfixToNFA = (postfix: PostfixNode[]): State | undefined => {\n  const stack: Frag[] = [];\n\n  each(postfix, (p) => {\n    if (p.type === 'operator') {\n      switch (p.value) {\n        // Concatenation\n        case '.':\n          {\n            const e2 = stack.pop();\n            const e1 = stack.pop();\n            if (!e1 || !e2) {\n              throw new Error('Invalid postfix expression');\n            }\n            patch(e1.out, e2.start);\n            stack.push({ start: e1.start, out: e2.out });\n          }\n          break;\n        // Alternation\n        case '|':\n          {\n            const e2 = stack.pop();\n            const e1 = stack.pop();\n            if (!e1 || !e2) {\n              throw new Error('Invalid postfix expression');\n            }\n            const s: State = { type: 'Split', out: e1.start, out1: e2.start };\n            stack.push({ start: s, out: [...e1.out, ...e2.out] });\n          }\n          break;\n        // Zero or one\n        case '?':\n          {\n            const e = stack.pop();\n            if (!e) {\n              throw new Error('Invalid postfix expression');\n            }\n            const s: State = { type: 'Split', out: e.start, out1: null };\n            stack.push({\n              start: s,\n              out: [{ state: s, outAttr: 'out1' }, ...e.out],\n            });\n          }\n          break;\n        // Zero or more\n        case '*':\n          {\n            const e = stack.pop();\n            if (!e) {\n              throw new Error('Invalid postfix expression');\n            }\n            const s: State = { type: 'Split', out: e.start, out1: null };\n            patch(e.out, s);\n            stack.push({ start: s, out: [{ state: s, outAttr: 'out1' }] });\n          }\n          break;\n        // One or more\n        case '+':\n          {\n            const e = stack.pop();\n            if (!e) {\n              throw new Error('Invalid postfix expression');\n            }\n            const s: State = { type: 'Split', out: e.start, out1: null };\n            patch(e.out, s);\n            stack.push({\n              start: e.start,\n              out: [{ state: s, outAttr: 'out1' }],\n            });\n          }\n          break;\n        default:\n          throw new Error(`Unknown operator: ${p.value}`);\n      }\n    } else {\n      const s: State = {\n        type: 'Char',\n        char: p.value,\n        notEqual: p.notEqual,\n        out: null,\n        out1: null,\n      };\n      stack.push({ start: s, out: [{ state: s, outAttr: 'out' }] });\n    }\n  });\n\n  // The stack should have only one fragment left.\n  // Patch in the match state.\n  const e = stack.pop();\n  if (!e) {\n    throw new Error('Invalid postfix expression');\n  }\n  patch(e.out, { type: 'Match', out: null, out1: null });\n\n  return e.start;\n};\n\ninterface MatchOptions {\n  // If true, the algorithm will try to match the longest possible string. If false, it will try to match the shortest possible string.\n  // default: true\n  greedy?: boolean;\n  // If true, the algorithm will try to match all occurrences of the pattern in the input string. If false, it will only try to match the first occurrence.\n  // default: false\n  global?: boolean;\n  // If true, the algorithm will ignore the case of the input string.\n  // default: false\n  ignoreCase?: boolean;\n  // If true, the algorithm will match from the start of the input string.\n  // default: false\n  matchFromStart?: boolean;\n  // If true, the algorithm will match to the end of the input string.\n  // default: false\n  matchToEnd?: boolean;\n  // If provided, the algorithm will replace the matched string with the return value of this function.\n  onReplace?: (val: string) => string;\n  // Size of the highWaterMark for the processing stream.\n  // default: 1024\n  processingStreamHighWaterMark?: number;\n}\n\ninterface _MatchResult {\n  matchedValue: string | undefined;\n  srcValue: string;\n}\n\n/**\n * Runs the NFA on the input string.\n *\n * @param start - The start state of the NFA.\n * @param input - Input stream to match.\n * @param options - Options for the match.\n */\nexport const match = (\n  start: State,\n  input: Readable,\n  options?: MatchOptions,\n) => {\n  // This ID is used to prevent adding the same state to a list multiple times.\n  // We do this by giving each state list a unique ID (listID) and then setting the lastList property of the state to the listID.\n  // If the lastList property of the state is the same as the listID, we skip adding the state to the list.\n  let listID = 1;\n  // Default options.\n  const opts: MatchOptions = {\n    greedy: true,\n    global: false,\n    ignoreCase: false,\n    processingStreamHighWaterMark: 1024,\n    ...options,\n  };\n\n  /**\n   * Adds a state to the list. Handles the split nodes by adding both out and out1 states.\n   *\n   * @param list\n   * @param s\n   */\n  const addState = (list: State[], s: State | null) => {\n    // If the state is null or the lastList property is the same as the listID, skip adding the state to the list.\n    if (s === null || s.lastListID === listID) {\n      return;\n    }\n\n    s.lastListID = listID;\n    // If the state is a split node, add both out and out1 states.\n    if (s.type === 'Split') {\n      addState(list, s.out);\n      addState(list, s.out1);\n      return;\n    }\n    list.push(s);\n  };\n\n  /**\n   * Runs one step of NFA on the input character.\n   * The output is the next state list.\n   *\n   * @param list\n   * @param grapheme - A grapheme is the smallest unit of a writing system that is capable of conveying a distinct meaning.\n   */\n  const step = (list: State[], grapheme: string) => {\n    debugLogger('[step] Step: %o', { listID, grapheme });\n\n    listID++;\n    const nextStates: State[] = [];\n    each(list, (state) => {\n      if (state.type === 'Char' && !isNil(state.char)) {\n        const srcGrapheme = opts.ignoreCase ? grapheme.toLowerCase() : grapheme;\n        const stateCharArray = isArray(state.char) ? state.char : [state.char];\n        const hasMatch = every(stateCharArray, (stateChar) => {\n          const stateGrapheme = opts.ignoreCase\n            ? stateChar.toLowerCase()\n            : stateChar;\n          return state.notEqual\n            ? stateGrapheme !== srcGrapheme\n            : stateGrapheme === srcGrapheme;\n        });\n        if (hasMatch) {\n          debugLogger('[step] Match: %o', state);\n          addState(nextStates, state.out);\n        } else {\n          debugLogger('[step] No match: %o', state);\n        }\n      }\n    });\n\n    debugLogger('[step] Next states: %o', nextStates);\n    return nextStates;\n  };\n\n  /**\n   * Main function. Runs the NFA on the input stream.\n   *\n   * @param start\n   * @param greedy\n   * @param highWaterMark\n   */\n  const _doMatchStream = (\n    start: State,\n    greedy: boolean,\n    highWaterMark?: number,\n  ) => {\n    let list: State[] = [];\n\n    let strBuffer = '';\n    let lastMatch: string | undefined = undefined;\n    let lastMatchEnd = 0;\n    const splitter = new Graphemer();\n\n    const matchStream = new PassThrough({\n      readableObjectMode: true,\n      writableHighWaterMark: highWaterMark,\n    });\n    matchStream._write = (chunk, encoding, callback) => {\n      const chunkStr = chunk.toString();\n      const graphemes = splitter.splitGraphemes(chunkStr);\n\n      for (const grapheme of graphemes) {\n        strBuffer += grapheme;\n\n        if (list.length === 0) {\n          // Start the state list by adding the start state.\n          addState(list, start);\n        }\n\n        list = step(list, grapheme);\n\n        // If we have a match, save the match and stop if not greedy.\n        if (some(list, (state) => state.type === 'Match')) {\n          debugLogger('[_doMatchStream] Has match');\n          lastMatch = strBuffer;\n          lastMatchEnd = strBuffer.length;\n\n          if (!greedy) {\n            matchStream.push({ matchedValue: lastMatch, srcValue: strBuffer });\n            strBuffer = '';\n            list = [];\n            lastMatch = undefined;\n            lastMatchEnd = 0;\n            addState(list, start);\n          }\n        }\n\n        // If we have no more states to go to, then there is a mismatch. Exit early.\n        if (list.length === 0) {\n          debugLogger('[_doMatchStream] No match - early exit');\n          matchStream.push({\n            matchedValue: lastMatch,\n            srcValue: lastMatch\n              ? strBuffer.substring(0, strBuffer.length - grapheme.length)\n              : strBuffer,\n          });\n          strBuffer = '';\n          list = [];\n          if (lastMatch) {\n            lastMatch = undefined;\n            // Move back one grapheme\n            strBuffer = grapheme;\n            addState(list, start);\n          }\n        }\n      }\n\n      callback();\n    };\n\n    // Flush any pending match.\n    matchStream._final = (callback) => {\n      if (lastMatch) {\n        matchStream.push({\n          matchedValue: lastMatch,\n          srcValue: strBuffer.substring(0, lastMatchEnd),\n        });\n        strBuffer = strBuffer.substring(lastMatchEnd);\n      }\n      if (strBuffer.length > 0) {\n        matchStream.push({ matchedValue: undefined, srcValue: strBuffer });\n      }\n      callback();\n    };\n\n    return matchStream;\n  };\n\n  /**\n   * Entry point for running the NFA on the input stream. This function progressively matches the input stream.\n   *\n   * @param start\n   * @param input\n   * @param options\n   */\n  const doMatchStream = (\n    start: State,\n    input: Readable,\n    options: MatchOptions,\n  ) => {\n    // Output stream.\n    const replaceStream = new Readable();\n    // TODO: Respect the highWaterMark.\n    replaceStream._read = () => {};\n\n    // First match success flag.\n    let matchSucceeded = false;\n    // Most recent matched string.\n    let lastMatchedString: string | undefined = undefined;\n    // Reject matching flag.\n    let rejectMatching = false;\n\n    const matchStream = _doMatchStream(\n      start,\n      options.greedy || false,\n      options.processingStreamHighWaterMark,\n    );\n    input\n      .pipe(matchStream)\n      .on('data', ({ matchedValue, srcValue }: _MatchResult) => {\n        let str = srcValue;\n\n        if (matchedValue) {\n          // If we're not matching globally, then we're done after the first match.\n          if (!rejectMatching && (options.global || !matchSucceeded)) {\n            if (options.onReplace) {\n              str = options.onReplace(matchedValue);\n            }\n          }\n          // Prevent further matching if we're matching globally.\n          matchSucceeded = true;\n\n          // If we're not matching to the end of stream, push the matched string to the output stream.\n          if (!options.matchToEnd) {\n            replaceStream.push(str);\n          } else if (!rejectMatching) {\n            // Record this match (used for end matching).\n            // The replacement processing is done at the end when the stream is finished. If subsequent chunks are not matched, then we'll need the original source string.\n            // NOTE: `global` has no effect on `matchToEnd`.\n            lastMatchedString = matchedValue;\n          }\n        } else {\n          // Start rejecting future matches after the first non-match if we're matching from the start.\n          rejectMatching = !!options.matchFromStart;\n          // On a non-match, the last matched string is treated as an unmatched string.\n          if (lastMatchedString) {\n            replaceStream.push(lastMatchedString);\n          }\n          replaceStream.push(str);\n          lastMatchedString = undefined;\n        }\n      })\n      .on('finish', () => {\n        // If we're matching to the end of stream, if a match has survived, run the replacement process and push to output.\n        if (options.matchToEnd) {\n          if (lastMatchedString) {\n            replaceStream.push(\n              options.onReplace\n                ? options.onReplace(lastMatchedString)\n                : lastMatchedString,\n            );\n          }\n        }\n        replaceStream.push(null);\n      });\n\n    return replaceStream;\n  };\n\n  // Start the NFA.\n  return doMatchStream(start, input, opts);\n};\n"],"mappings":"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"}