{"version":3,"file":"regex.ohm-bundle.d.js","names":[],"sources":["../../src/grammar/regex.ohm-bundle.d.ts"],"sourcesContent":["// AUTOGENERATED FILE\n// This file was generated from regex.ohm by `ohm generateBundles`.\n\nimport {\n  BaseActionDict,\n  Grammar,\n  IterationNode,\n  Node,\n  NonterminalNode,\n  Semantics,\n  TerminalNode\n} from 'ohm-js';\n\nexport interface RegExpActionDict<T> extends BaseActionDict<T> {\n  expression?: (this: NonterminalNode, arg0: IterationNode, arg1: NonterminalNode, arg2: IterationNode, arg3: IterationNode) => T;\n  subExpression?: (this: NonterminalNode, arg0: IterationNode) => T;\n  expressionItem?: (this: NonterminalNode, arg0: NonterminalNode) => T;\n  group?: (this: NonterminalNode, arg0: NonterminalNode) => T;\n  groupExpression?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: NonterminalNode, arg3: TerminalNode, arg4: IterationNode) => T;\n  match?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode) => T;\n  matchItem?: (this: NonterminalNode, arg0: NonterminalNode) => T;\n  anyChar?: (this: NonterminalNode, arg0: TerminalNode) => T;\n  escapeCharacter?: (this: NonterminalNode, arg0: TerminalNode) => T;\n  specialCharacter?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;\n  characterClass?: (this: NonterminalNode, arg0: TerminalNode) => T;\n  baseCharacter?: (this: NonterminalNode, arg0: NonterminalNode) => T;\n  character?: (this: NonterminalNode, arg0: IterationNode | NonterminalNode, arg1: NonterminalNode) => T;\n  matchCharacterClass?: (this: NonterminalNode, arg0: NonterminalNode) => T;\n  characterGroup?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: NonterminalNode, arg3: TerminalNode) => T;\n  characterGroupInner?: (this: NonterminalNode, arg0: IterationNode) => T;\n  characterGroupItem?: (this: NonterminalNode, arg0: NonterminalNode) => T;\n  characterRange?: (this: NonterminalNode, arg0: NonterminalNode) => T;\n  characterRangeItem?: (this: NonterminalNode, arg0: NonterminalNode, arg1: TerminalNode, arg2: NonterminalNode) => T;\n  anchor?: (this: NonterminalNode, arg0: TerminalNode) => T;\n  quantifier?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode) => T;\n  quantifierType?: (this: NonterminalNode, arg0: TerminalNode) => T;\n}\n\nexport interface RegExpSemantics extends Semantics {\n  addOperation<T>(name: string, actionDict: RegExpActionDict<T>): this;\n  extendOperation<T>(name: string, actionDict: RegExpActionDict<T>): this;\n  addAttribute<T>(name: string, actionDict: RegExpActionDict<T>): this;\n  extendAttribute<T>(name: string, actionDict: RegExpActionDict<T>): this;\n}\n\nexport interface RegExpGrammar extends Grammar {\n  createSemantics(): RegExpSemantics;\n  extendSemantics(superSemantics: RegExpSemantics): RegExpSemantics;\n}\n\ndeclare const grammar: RegExpGrammar;\nexport default grammar;\n\n"],"mappings":""}